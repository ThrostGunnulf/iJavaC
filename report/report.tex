% !TeX spellcheck = pt_PT
\documentclass[11pt,a4paper]{article}
\usepackage{etex}
\reserveinserts{28}

\usepackage[utf8]{inputenc}

\usepackage{hyperref}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage[portuguese]{babel}
\usepackage{pictex}
\usepackage[dvips]{graphics}
\usepackage{enumerate}
\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage[portuguese]{babel}
\usepackage{pictex}
\usepackage[dvips]{graphics}
\usepackage{enumerate}
\usepackage{color}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{float}
\usepackage{makeidx}

\usepackage[margin=1.3in]{geometry}

\usepackage{graphicx}
\setlength{\parindent}{1cm}


%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\newcommand*{\titleGM}{\begingroup % Create the command for including the title page in the document
\hbox{ % Horizontal box
\hspace*{0.2\textwidth} % Whitespace to the left of the title page
\rule{1pt}{\textheight} % Vertical line
\hspace*{0.05\textwidth} % Whitespace between the vertical line and title page text
\parbox[b]{0.75\textwidth}{ % Paragraph box which restricts text to less than the width of the page

{\noindent\Huge\bfseries Compilador \\[0.5\baselineskip] iJava}\\[2\baselineskip] % Title
{\large \textit{Projecto da Cadeira de Compiladores}}\\[4\baselineskip] % Tagline or further description
{\Large \textsc{JOÃO OLIVEIRA - 2010129856}} \\ \\ % Author name
{\Large \textsc{JOÃO SIMOES - 2011150045}} % Author name

\vspace{0.5\textheight} % Whitespace between the title block and the publisher
{\noindent FCTUC - Departamento de Engenharia Informática}\\[\baselineskip] % Publisher and logo
}}
\endgroup}

\begin{document}

\titleGM

\section{Inrodução}

Este projecto consistiu no desenvolvimento de um compilado para a linguagem $iJava$. Esta línguagem apresenta diversas caracteristicas específicas a serem descritas de seguida.

Uma das características prende-se com o facto de cada programa conter uma única classe. Esta classe pode ter incluídas variáveis estáticas e métodos \emph{public static}, assim como variáveis locais. Para além disto, é mandatória a presença de um método \emph{main}, método este a ser chamado aquando da execução do programa. Este mesmo método tem como parâmetro, por defeito, um array de \emph{Strings}, contendo os parâmetos de entrada.

É ainda possível implementar expressões aritméticas e lógicas, assim como operações de atribuição, relacionais e controlo. (\emph{if-else} e \emph{while} )

Relativamente aos tipos de variáveis existentes na linguagem, é possivel usar varíaveis do tipo \emph{Integer} e \emph{Boolean}. É ainda possível criar arrays unidimensionais dos tipo apresentados anteriormente.

Por fim, o desenvolvimento do compilador deu-se em várias fases bem definidas, fases estas que apresentamos de seguida.

\begin{description}
	\item[Fase 1] Análise Lexical
		\begin{itemize}
			\item Identificação dos tokens aceites pela linguagem e tradução dos mesmo para a linguagem \emph{LEX}. 
		\end{itemize}
	\item[Fase 2] Análise Sintática
		\begin{itemize}
			\item Tradução da gramática dada para a linguagem \emph{YACC} e resolução de conflitos e ambiguidades;
			\item Estruturas de dados a serem criadas de forma a representar os nós da Árvore de Sintaxe Abstracta;
			\item Definição de enumerações de forma a representar os diversos tipos de operações,  expressões, \emph{statments}, entre outros;
			\item Implementação das funções responsáveis pela construção da AST;
			\item Deteção de erros sintáticos.
		\end{itemize}
	\item[Fase 3] Análise Semântica
		\begin{itemize}
			\item Definição das estruturas de dados a serem utilizadas para a criação da tabela de símbolos;
			\item Implementação dos procedimentos responsáveis pelas inserções na tabela de símbolos;
			\item Detecção de erros ao nível semântico. 
		\end{itemize}
	\item[Fase 4] Geração de código intermédio
		\begin{itemize}
			\item Implemententação das funções responsáveis pela geração de código \emph{LLVM}.
		\end{itemize}
\end{description}

\newpage

\section{Análise Léxical}

A primeira fase da construção do compilador consistiu na definição dos tokens aceites pela linguagem, através de expressões regulares, sendo internamente construído pelo \emph{LEX} um autómato não-determinístico capaz de reconhecer a linguagem.

\subsection{Tokens}

Após terminada a análise sintáticta, obtivemos os seguintes \emph{tokens}:

\begin{itemize}
	\item \textbf{INT} - \emph{int} 
	\item \textbf{BOOL} - \emph{boolean}
	\item \textbf{NEW} - \emph{new}
	\item \textbf{IF} - \emph{if}
	\item \textbf{ELSE} - \emph{else}
	\item \textbf{WHILE} - \emph{while}
	\item \textbf{PRINT} - \emph{System.out.println}
	\item \textbf{PARSERINT} - \emph{Integer.parseInt}
	\item \textbf{CLASS} - \emph{class}
	\item \textbf{PUBLIC} - \emph{public}
	\item \textbf{STATIC} - \emph{static}
	\item \textbf{VOID} - \emph{void}
	\item \textbf{STRING} - \emph{String}
	\item \textbf{DOTLENGTH} - \emph{length}
	\item \textbf{RETURN} - \emph{return}
	\item \textbf{OCURV} - $($
	\item \textbf{CCURV} - $)$
	\item \textbf{OBRACE} - \{
	\item \textbf{CBRACE} - \}
	\item \textbf{OSQUARE} - [
	\item \textbf{CSQUARE} - ]
	\item \textbf{OP1} - \&\& , $\|$
	\item \textbf{OP2} - $< , > , == , != , <= , >=$
	\item \textbf{OP3} - $+ , -$
	\item \textbf{OP4} - $* , / , \% $
	\item \textbf{NOT} - !
	\item \textbf{ASSIGN} - \emph{printf}
	\item \textbf{SEMIC} - ;
	\item \textbf{COMMA} - ,
	\item \textbf{BOOLLIT} - \emph{true false}
	\item \textbf{ID} - Corresponde a todas as sequências alfanuméricas inciadas por uma letra(maiúscula ou minúscula), que podem conter os caractéres "\$" e "$\_$".
\end{itemize}

\subsection{Detecção de Erros Lexícais}

A análise lexical é realizada da esquerda para a direita, caractér a caractér, até ao momento em que o autómato atinge um estado morto. Quando este mesmo estado é atingido, o analisador percorre o caminho inverso até encontrar um estado final, estando então encontrado um \emph{token} válido. Caso o analisador não atinja um estado final, então é gerado um erro léxical. Para melhor identificação do erro lexícal, é impressa a linha e a coluna onde se encontra o mesmo. Assim, necessitamos de mecanismos para obter estas informações.

Para tal, existe uma varíavel com o nome \emph{colNo}, responsável por armazenar a coluna actual, sendo esta variável incrementada quando se verifica uma mudança de lina . Relativamente à linha, obtemos o seu valor actual através da varíavel \emph{yylineno}, já implementada pelo \emph{YACC}.



\subsection{Tratamento dos Comentários}

A linguagem iJava permite a existência de comentários de linha(iniciado por "$\|$") e comentários de bloco(colocados entre "$/* */$").

\newpage

\section{Análise Sintática}

Após terminada a fase da análise lexical, segue-se a análise sintática. Uma vez que nesta vamos ter em conta as precedências dos operadores, foram feitos alguns ajustes nos tokens detectados. Estas alterções serão explicadas de seguida.

\subsection{Alterações na Análise Léxical}

Como dito anteriormente, houve necessidade de efectuar algumas alterações à organização dos \emph{tokens} realtivos aos operadores. Estas alterações devem-se à necessidade de termos em conta as precedências dos operadores. Assim, após alterações obtivemos os seguintes tokens relativos aos operadores.

\begin{itemize}
	\item \textbf{AND} - \&\&
	\item \textbf{OR} - $\|$
	\item \textbf{RELCOMPAR} - $< , >, <= , >=$
	\item \textbf{EQUALITY} -  $, == , !=$ 
	\item \textbf{ADDITIVE} - $ , == , != $
	\item \textbf{MULTIPLIC} - $* , / , \% $
\end{itemize}

Para além das alterações acima referidas, foram ainda feitas outras em relação à contagem da linha e da coluna. Uma vez que aquando da mostragem da mensagem de erro sintático, o número da linha e da coluna apresentadas têm de corresponder ao inicio do \emph{token} inválido. Logo, esta informação foi guardada de forma a depois ser acedida no analisador sintático.

\subsection{Gramática da Linguagem}

A gramática da linguagem \emph{iJava}, apresenta-se de seguida segundo a notação \emph{EBNF}: 
\vspace{0.5cm}

\hspace{-1cm}\vspace{.1cm}Start $\rightarrow$ Program \\ \\
\vspace{.5cm}Program $\rightarrow$ CLASS ID OBRACE { FieldDecl $\mid$ MethodDecl } CBRACE\\
\vspace{.5cm}FieldDecl $\rightarrow$ STATIC VarDecl\\
MethodDecl $\rightarrow$ PUBLIC STATIC ( Type $\mid$ VOID ) ID OCURV [ FormalParams ] CCURV OBRACE { VarDecl } { Statement } CBRACE\\ \\
\vspace{.5cm}FormalParams $\rightarrow$ Type ID { COMMA Type ID }\\
\vspace{.5cm}FormalParams $\rightarrow$ STRING OSQUARE CSQUARE ID\\
\vspace{.5cm}VarDecl $\rightarrow$ Type ID { COMMA ID } SEMIC\\
\vspace{.5cm}Type $\rightarrow$ ( INT $\mid$ BOOL ) [ OSQUARE CSQUARE ]\\
\vspace{.5cm}Statement $\rightarrow$ OBRACE { Statement } CBRACE\\
\vspace{.5cm}Statement $\rightarrow$ IF OCURV Expr CCURV Statement [ ELSE Statement ]\\
\vspace{.5cm}Statement $\rightarrow$ WHILE OCURV Expr CCURV Statement\\
\vspace{.5cm}Statement $\rightarrow$ PRINT OCURV Expr CCURV SEMIC\\
\vspace{.5cm}Statement $\rightarrow$ ID [ OSQUARE Expr CSQUARE ] ASSIGN Expr SEMIC\\
\vspace{.5cm}Statement $\rightarrow$ RETURN [ Expr ] SEMIC\\
\vspace{.5cm}Expr $\rightarrow$ Expr ( OP1 $\mid$ OP2 $\mid$ OP3 $\mid$ OP4 ) Expr\\
\vspace{.5cm}Expr $\rightarrow$ Expr OSQUARE Expr CSQUARE\\
\vspace{.5cm}Expr $\rightarrow$ ID $\mid$ INTLIT $\mid$ BOOLLIT\\
\vspace{.5cm}Expr $\rightarrow$ NEW ( INT $\mid$ BOOL ) OSQUARE Expr CSQUARE\\
\vspace{.5cm}Expr $\rightarrow$ OCURV Expr CCURV\\
\vspace{.5cm}Expr $\rightarrow$ Expr DOTLENGTH $\mid$ ( OP3 $\mid$ NOT ) Expr\\
\vspace{.5cm}Expr $\rightarrow$ PARSEINT OCURV ID OSQUARE Expr CSQUARE CCURV\\
\vspace{.5cm}Expr $\rightarrow$ ID OCURV [ Args ] CCURV\\
\vspace{.5cm}Args $\rightarrow$ Expr { COMMA Expr }\\


Após a interpretação da gramática dada, definimos a gramática seguindo a notação do \emph{YACC}. A gramática obtida após definição de precedências e após alterações relativamente à gramática acima, foi a seguinte seguida(todas as alterações e definições de precedências serão abordadas com detalhe nas proximas secções).

\vspace{0.7cm}

\lstset{language=C,caption={Gramática obtida segundo a representação do YACC},label=Estruturas,numbers=left,frame=single, breaklines = true}
\begin{lstlisting}

start: CLASS ID '{' decls '}'
	 | CLASS ID '{' '}'

decls: decls fielddecl
     | decls methoddecl

fielddecl: STATIC type ID idlist ';'

methoddecl: PUBLIC STATIC methodtype ID '(' formalparams ')' '{' vardecl stmtlist '}'

methodtype: type 
          | VOID
          
formalparams: type ID formalparamslist
            | STRING '[' ']' ID
            |

formalparamslist: formalparamslist ',' type ID   
                |

stmtlist: stmtlist statement
        |

vardecl: vardecl type ID idlist ';'
	   |

idlist: idlist ',' ID
      |

type: INT '[' ']'
    | BOOL '[' ']'
    | INT
    | BOOL

statement: '{' stmtlist '}'
         | IF '(' expr ')' statement ELSE statement  %prec ELSE
         | IF '(' expr ')' statement    %prec IFX   
         | WHILE '(' expr ')' statement
         | PRINT '(' expr ')' ';'
         | ID '[' expr ']' '=' expr ';' 
         | ID '=' expr ';'
         | RETURN expr ';'
         | RETURN ';'         

expr: exprindex
	| exprnotindex
	
exprindex: ID
     	 | INTLIT
     	 | BOOLLIT
     	 | '(' expr ')'
     	 | expr DOTLENGTH
     	 | PARSEINT '(' ID '[' expr ']' ')'
     	 | ID '(' args ')'
     	 | ID '(' ')'
         | exprindex '[' expr ']'

exprnotindex: NEW INT '[' expr ']'
     		| NEW BOOL '[' expr ']'
     	 	| '!' expr               %prec UNARY
     	 	| ADDITIVE expr          %prec UNARY
     	 	| expr AND expr
     	 	| expr OR expr
     	 	| expr RELCOMPAR expr
     	 	| expr EQUALITY expr
     	 	| expr ADDITIVE expr
     	 	| expr MULTIPLIC expr

args: expr argslist
    | expr
 
argslist: ',' args

   
\end{lstlisting}

\subsection{Tradução da Gramática dada para o YACC}

Como referido anteriormente, foram necessárias diversas alterações à gramática dada na notação \emph{EBNF}. Nesta sub-secção vamos referenciar essas alterações explicando o seu porquê.

Uma das alterações efectuadas, é relativa à abordagem do que é "opcional"$([\dots])$, que tem "zero ou mais repetições"$(\{\dots\})$ e situações em que temos várias opções.

\begin{itemize}
	\item Nas situações em que temos símbolos "opciaís", dividimos a regra em duas regras distintas como forma de abrager os dois casos, ou seja, o caso em que tem o simbolo e o caso em que não. Noutros casos, simplesmente consideramos a possiblidade de ter a String vazia aos símbolos poderem ser opcionais.
	
	\item Quando existem "zero ou mais repetições", consideramos a possibilidade da String vazia, sendo ainda adicionada a recursividade de forma a permitir várias repetições da mesma regra.
	
	\item No caso de termos várias opções relativamente ao simbolo, é criada uma nova regra que contempla todas os simbolos possíveis.  
\end{itemize} 

Outras alterações efectuadas têm a ver com a definição de precedência de operadores. Apresentamos abaixo as precedências definidas no \emph{YACC}.

\newpage 
 
\lstset{language=C,caption={Precedências},label=Estruturas,frame=single, breaklines = true}
\begin{lstlisting}
 %left OR
 %left AND
 %left EQUALITY
 %left RELCOMPAR
 %left ADDITIVE
 %left MULTIPLIC
 %right UNARY
 %left '[' DOTLENGTH
\end{lstlisting}

\end{document}